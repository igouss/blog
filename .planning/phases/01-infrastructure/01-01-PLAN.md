---
phase: 01-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - /srv/blog/configs/Caddyfile
  - /srv/blog/index.html
  - /etc/default/tailscaled
autonomous: true
requirements:
  - INFRA-01
  - INFRA-02

must_haves:
  truths:
    - "/srv/blog directory tree exists with articles/, templates/, css/, scripts/, configs/ subdirectories"
    - "caddy user can read /srv/blog (ownership or world-readable)"
    - "TS_PERMIT_CERT_UID=caddy is set in /etc/default/tailscaled"
    - "tailscaled is running with the updated env var in effect"
  artifacts:
    - path: "/srv/blog/configs/Caddyfile"
      provides: "Phase 1 minimal Caddyfile (source of truth)"
    - path: "/srv/blog/index.html"
      provides: "Placeholder HTML for pipeline validation"
    - path: "/etc/default/tailscaled"
      provides: "tailscaled env config granting Caddy TLS cert access"
  key_links:
    - from: "/etc/default/tailscaled"
      to: "tailscaled TLS cert socket"
      via: "TS_PERMIT_CERT_UID=caddy env var"
      pattern: "TS_PERMIT_CERT_UID=caddy"
    - from: "/srv/blog"
      to: "caddy process"
      via: "chown caddy:caddy"
      pattern: "caddy:caddy /srv/blog"
---

<objective>
Create the blog directory layout on the Fedora host and grant Caddy permission to fetch TLS certs from tailscaled.

Purpose: These are the two prerequisites everything else in Phase 1 depends on. The directory tree must exist before Caddy can serve files. The TS_PERMIT_CERT_UID must be in effect before Caddy starts — if tailscaled is not restarted with this var, Caddy will fail to obtain the *.ts.net certificate.

Output: /srv/blog tree with correct ownership, /srv/blog/configs/Caddyfile (source of truth), /srv/blog/index.html (pipeline validation placeholder), /etc/default/tailscaled updated, tailscaled restarted.
</objective>

<execution_context>
@/home/elendal/.claude/get-shit-done/workflows/execute-plan.md
@/home/elendal/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-infrastructure/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create blog directory layout and set ownership</name>
  <files>/srv/blog/articles/ /srv/blog/templates/ /srv/blog/css/ /srv/blog/scripts/ /srv/blog/configs/ /srv/blog/index.html</files>
  <action>
Run on the Fedora host:

```bash
sudo mkdir -p /srv/blog/{articles,templates,css,scripts,configs}
sudo chown -R caddy:caddy /srv/blog
```

Then create the placeholder HTML at /srv/blog/index.html (owned by caddy):

```bash
sudo tee /srv/blog/index.html <<'EOF'
<!DOCTYPE html>
<html><head><title>Blog</title></head>
<body><h1>Blog coming soon</h1></body>
</html>
EOF
sudo chown caddy:caddy /srv/blog/index.html
```

Rationale for /srv/blog: Fedora's /srv path carries httpd_sys_content_t SELinux context by default, so no semanage labeling is needed. Do NOT use /home, /opt, or other paths without first applying SELinux labels.

Rationale for chown caddy:caddy: The COPR-installed caddy.service runs as the caddy user. If caddy cannot read /srv/blog, all file requests return 403 regardless of Unix permissions.
  </action>
  <verify>
```bash
ls -la /srv/blog/
# Expected: articles/ templates/ css/ scripts/ configs/ index.html — all owned caddy:caddy
stat -c "%U:%G %n" /srv/blog /srv/blog/articles /srv/blog/index.html
# Expected: caddy:caddy for each entry
ls -laZ /srv/blog/ | head -5
# Expected: httpd_sys_content_t or similar label (no denial-prone label like user_home_t)
```
  </verify>
  <done>All five subdirectories and index.html exist under /srv/blog; all entries owned caddy:caddy; SELinux context is httpd_sys_content_t or compatible type.</done>
</task>

<task type="auto">
  <name>Task 2: Write Phase 1 Caddyfile into configs/</name>
  <files>/srv/blog/configs/Caddyfile</files>
  <action>
Write the minimal Phase 1 Caddyfile to /srv/blog/configs/Caddyfile. This is the source-of-truth config that will be symlinked to /etc/caddy/Caddyfile in Plan 02.

Phase 1 only needs HTTPS + static file serving. Do NOT add template, rewrite, or content-negotiation directives — those are Phase 2.

```caddyfile
fedora.mist-walleye.ts.net {
    root * /srv/blog

    # Serve static files
    file_server

    # Tailscale TLS — Caddy auto-fetches cert for *.ts.net domains.
    # Explicit tls block is belt-and-suspenders; safe to include.
    tls {
        get_certificate tailscale
    }
}
```

Write this with:
```bash
sudo tee /srv/blog/configs/Caddyfile <<'EOF'
fedora.mist-walleye.ts.net {
    root * /srv/blog

    file_server

    tls {
        get_certificate tailscale
    }
}
EOF
sudo chown caddy:caddy /srv/blog/configs/Caddyfile
```

Site address MUST be `fedora.mist-walleye.ts.net` — not `blog.mist-walleye.ts.net` (no CNAME exists, locked decision).
  </action>
  <verify>
```bash
cat /srv/blog/configs/Caddyfile
# Expected: fedora.mist-walleye.ts.net block with file_server and tls { get_certificate tailscale }
stat -c "%U:%G %n" /srv/blog/configs/Caddyfile
# Expected: caddy:caddy /srv/blog/configs/Caddyfile
```
  </verify>
  <done>Caddyfile exists at /srv/blog/configs/Caddyfile, contains fedora.mist-walleye.ts.net site block with file_server and get_certificate tailscale, owned caddy:caddy.</done>
</task>

<task type="auto">
  <name>Task 3: Set TS_PERMIT_CERT_UID and restart tailscaled</name>
  <files>/etc/default/tailscaled</files>
  <action>
Grant the caddy user permission to fetch TLS certs from tailscaled. This MUST be done and tailscaled MUST be restarted BEFORE Caddy is started — if the order is reversed, Caddy fails to obtain the *.ts.net certificate.

Check idempotently to avoid duplicate entries:
```bash
# Check if already set
grep -q 'TS_PERMIT_CERT_UID=caddy' /etc/default/tailscaled 2>/dev/null \
  && echo "Already set — no change needed" \
  || { sudo tee -a /etc/default/tailscaled <<< 'TS_PERMIT_CERT_UID=caddy' && echo "Added TS_PERMIT_CERT_UID=caddy"; }
```

If /etc/default/tailscaled does not exist, the append above creates it. Either way, restart tailscaled:
```bash
sudo systemctl restart tailscaled
sudo systemctl is-active tailscaled
```

Source: https://tailscale.com/kb/1190/caddy-certificates — official Tailscale Caddy cert docs.
  </action>
  <verify>
```bash
grep 'TS_PERMIT_CERT_UID=caddy' /etc/default/tailscaled
# Expected: TS_PERMIT_CERT_UID=caddy (exactly one occurrence)

sudo systemctl is-active tailscaled
# Expected: active

# Confirm env var is visible to the running tailscaled process
sudo systemctl show tailscaled --property=Environment | grep -i permit
# Expected: ...TS_PERMIT_CERT_UID=caddy... (or confirm in show output)
```
  </verify>
  <done>TS_PERMIT_CERT_UID=caddy appears exactly once in /etc/default/tailscaled; tailscaled is active; the env var is in effect for the running process.</done>
</task>

</tasks>

<verification>
After all three tasks, confirm the host is ready for Plan 02 (Caddy TLS config):

```bash
# 1. Directory tree exists
ls /srv/blog/{articles,templates,css,scripts,configs}

# 2. Placeholder content in place
curl -s file:///srv/blog/index.html | grep "Blog coming soon"
# (or just: cat /srv/blog/index.html)

# 3. Caddyfile is ready
grep 'fedora.mist-walleye.ts.net' /srv/blog/configs/Caddyfile

# 4. tailscaled env var in place and process running
grep 'TS_PERMIT_CERT_UID=caddy' /etc/default/tailscaled
sudo systemctl is-active tailscaled
```
</verification>

<success_criteria>
- /srv/blog/{articles,templates,css,scripts,configs} all exist, owned caddy:caddy
- /srv/blog/index.html exists with placeholder HTML content, owned caddy:caddy
- /srv/blog/configs/Caddyfile exists with fedora.mist-walleye.ts.net site block
- /etc/default/tailscaled contains TS_PERMIT_CERT_UID=caddy
- tailscaled is active (systemd)
</success_criteria>

<output>
After completion, create `.planning/phases/01-infrastructure/01-01-SUMMARY.md` with files created, commands run, and any issues encountered.
</output>
